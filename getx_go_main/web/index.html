<!DOCTYPE html>
<html>
<head>
  <!--
    If you are serving your web app in a path other than the root, change the
    href value below to reflect the base path you are serving from.

    The path provided below has to start and end with a slash "/" in order for
    it to work correctly.

    For more details:
    * https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base

    This is a placeholder for base href that will be replaced by the value of
    the `--base-href` argument provided to `flutter build`.
  -->
  <base href="$FLUTTER_BASE_HREF">

  <meta charset="UTF-8">
  <meta content="IE=Edge" http-equiv="X-UA-Compatible">
  <meta name="description" content="A new Flutter project.">

  <!-- iOS meta tags & icons -->
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="apple-mobile-web-app-title" content="example">
  <link rel="apple-touch-icon" href="icons/Icon-192.png">

  <!-- Favicon -->
  <link rel="icon" type="image/png" href="favicon.png"/>

  <title>example</title>
  <link rel="manifest" href="manifest.json">
  
  <!-- 预加载字体 - 提高字体加载优先级 -->
  <link rel="preload" href="assets/fonts/NotoSansSC-Regular.ttf" as="font" type="font/ttf" crossorigin>
  <link rel="preload" href="assets/fonts/Roboto-Regular.ttf" as="font" type="font/ttf" crossorigin>
  <link rel="preload" href="assets/fonts/Roboto-Bold.ttf" as="font" type="font/ttf" crossorigin>
  
  <style>
    /* 定义字体 - 使用 font-display: swap 防止文字闪烁 */
    @font-face {
      font-family: 'Noto Sans SC';
      src: url('assets/fonts/NotoSansSC-Regular.ttf') format('truetype');
      font-weight: 400;
      font-style: normal;
      font-display: swap; /* 先显示系统字体，字体加载完后再切换 */
    }
    
    @font-face {
      font-family: 'Roboto';
      src: url('assets/fonts/Roboto-Regular.ttf') format('truetype');
      font-weight: 400;
      font-style: normal;
      font-display: swap;
    }
    
    @font-face {
      font-family: 'Roboto';
      src: url('assets/fonts/Roboto-Bold.ttf') format('truetype');
      font-weight: 700;
      font-style: normal;
      font-display: swap;
    }
    
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 50%, #0a0a0a 100%);
      overflow: hidden;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    }

    #loading-container {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 9999;
      background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 50%, #0a0a0a 100%);
      transition: opacity 0.8s ease-out;
    }

    #loading-container.fade-out {
      opacity: 0;
      pointer-events: none;
    }

    /* 粒子背景 */
    #particles-canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 1;
    }

    /* 主加载器容器 */
    .loader-wrapper {
      position: relative;
      z-index: 2;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 40px;
    }

    /* 3D旋转环 */
    .rings-container {
      position: relative;
      width: 200px;
      height: 200px;
      perspective: 1000px;
    }

    .ring {
      position: absolute;
      top: 50%;
      left: 50%;
      transform-style: preserve-3d;
      border-radius: 50%;
      border: 3px solid transparent;
      animation: rotate3d 3s infinite linear;
    }

    /* 外环 */
    .ring-1 {
      width: 200px;
      height: 200px;
      margin: -100px 0 0 -100px;
      border-color: rgba(99, 102, 241, 0.8);
      box-shadow: 0 0 30px rgba(99, 102, 241, 0.6), inset 0 0 30px rgba(99, 102, 241, 0.3);
      animation-duration: 6s;
    }

    /* 中环 */
    .ring-2 {
      width: 160px;
      height: 160px;
      margin: -80px 0 0 -80px;
      border-color: rgba(139, 92, 246, 0.8);
      box-shadow: 0 0 30px rgba(139, 92, 246, 0.6), inset 0 0 30px rgba(139, 92, 246, 0.3);
      animation-duration: 5s;
      animation-direction: reverse;
    }

    /* 内环 */
    .ring-3 {
      width: 120px;
      height: 120px;
      margin: -60px 0 0 -60px;
      border-color: rgba(236, 72, 153, 0.8);
      box-shadow: 0 0 30px rgba(236, 72, 153, 0.6), inset 0 0 30px rgba(236, 72, 153, 0.3);
      animation-duration: 2s;
    }

    /* 中心发光球 */
    .core {
      position: absolute;
      top: 50%;
      left: 50%;
      width: 60px;
      height: 60px;
      margin: -30px 0 0 -30px;
      border-radius: 50%;
      background: radial-gradient(circle, #fff 0%, rgba(99, 102, 241, 0.8) 50%, transparent 100%);
      box-shadow: 0 0 40px rgba(99, 102, 241, 1), 0 0 60px rgba(139, 92, 246, 0.8);
      animation: pulse 2s infinite ease-in-out;
    }

    @keyframes rotate3d {
      0% {
        transform: rotateX(0deg) rotateY(0deg) rotateZ(0deg);
      }
      100% {
        transform: rotateX(360deg) rotateY(360deg) rotateZ(360deg);
      }
    }

    @keyframes pulse {
      0%, 100% {
        transform: scale(1);
        opacity: 1;
      }
      50% {
        transform: scale(1.2);
        opacity: 0.8;
      }
    }

    /* 进度条 */
    .progress-container {
      width: 300px;
      height: 6px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 10px;
      overflow: hidden;
      position: relative;
      box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.5);
    }

    .progress-bar {
      height: 100%;
      background: linear-gradient(90deg, #6366f1, #8b5cf6, #ec4899);
      border-radius: 10px;
      width: 0%;
      box-shadow: 0 0 20px rgba(99, 102, 241, 0.8);
      position: relative;
      overflow: hidden;
      transition: width 0.3s ease-out;
    }

    .progress-bar::after {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.4), transparent);
      animation: shimmer 1.5s infinite;
    }

    @keyframes shimmer {
      0% { left: -100%; }
      100% { left: 200%; }
    }

    /* Logo 样式 */
    .logo-container {
      margin-bottom: 30px;
      display: flex;
      align-items: center;
      justify-content: center;
      gap:0px;
      animation: fadeInDown 0.8s ease-out;
    }

    .logo-image {
      height: 320px;
      object-fit: contain;
      filter: drop-shadow(0 0 20px rgba(99, 102, 241, 0.6));
      animation: logoFloat 3s ease-in-out infinite;
    }
    
    /* 专门针对 Flutter Logo 的样式 */
    .flutter-logo {
      height: 130px;
    }

    .app-title {
      color: #fff;
      font-size: 62px;
      font-weight: 600;
      text-align: center;
      letter-spacing: 1px;
      background: linear-gradient(135deg, #6366f1, #8b5cf6, #ec4899);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      animation: titleGlow 2s infinite ease-in-out;
    }

    @keyframes logoFloat {
      0%, 100% {
        transform: translateY(0px) rotate(0deg);
      }
      50% {
        transform: translateY(-10px) rotate(5deg);
      }
    }

    @keyframes fadeInDown {
      from {
        opacity: 0;
        transform: translateY(-30px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    @keyframes titleGlow {
      0%, 100% {
        filter: drop-shadow(0 0 10px rgba(99, 102, 241, 0.5));
      }
      50% {
        filter: drop-shadow(0 0 20px rgba(139, 92, 246, 0.8));
      }
    }

    /* 加载文本 */
    .loading-text {
      color: #fff;
      font-size: 24px;
      font-weight: 600;
      text-align: center;
      margin-top: -10px;
      letter-spacing: 2px;
      text-shadow: 0 0 20px rgba(99, 102, 241, 0.8);
      animation: textGlow 2s infinite ease-in-out;
    }

    .loading-subtext {
      color: rgba(255, 255, 255, 0.6);
      font-size: 14px;
      margin-top: 10px;
      letter-spacing: 1px;
    }

    .progress-info {
      display: flex;
      justify-content: space-between;
      align-items: center;
      width: 300px;
      margin-top: 8px;
      font-size: 12px;
      color: rgba(255, 255, 255, 0.5);
    }

    .progress-percent {
      font-weight: 700;
      color: #6366f1;
      font-size: 16px;
      text-shadow: 0 0 10px rgba(99, 102, 241, 0.5);
    }

    .loading-stats {
      font-size: 14px;
      font-weight: 500;
      color: rgba(255, 255, 255, 0.7);
      letter-spacing: 0.5px;
    }

    @keyframes textGlow {
      0%, 100% {
        text-shadow: 0 0 20px rgba(99, 102, 241, 0.8), 0 0 30px rgba(139, 92, 246, 0.6);
      }
      50% {
        text-shadow: 0 0 30px rgba(99, 102, 241, 1), 0 0 40px rgba(139, 92, 246, 0.8), 0 0 50px rgba(236, 72, 153, 0.6);
      }
    }

    /* 装饰性光线 */
    .light-beam {
      position: absolute;
      width: 2px;
      height: 100px;
      background: linear-gradient(180deg, transparent, rgba(99, 102, 241, 0.8), transparent);
      animation: beam 3s infinite ease-in-out;
    }

    .light-beam:nth-child(1) {
      top: 10%;
      left: 20%;
      animation-delay: 0s;
    }

    .light-beam:nth-child(2) {
      top: 30%;
      right: 15%;
      animation-delay: 0.5s;
    }

    .light-beam:nth-child(3) {
      bottom: 20%;
      left: 30%;
      animation-delay: 1s;
    }

    .light-beam:nth-child(4) {
      bottom: 10%;
      right: 25%;
      animation-delay: 1.5s;
    }

    @keyframes beam {
      0%, 100% {
        opacity: 0;
        transform: translateY(0) scaleY(0.5);
      }
      50% {
        opacity: 1;
        transform: translateY(-20px) scaleY(1);
      }
    }
  </style>
</head>
<body>
  <!-- 加载动画容器 -->
  <div id="loading-container">
    <!-- 粒子背景 -->
    <canvas id="particles-canvas"></canvas>
    
    <!-- 装饰光束 -->
    <div class="light-beam"></div>
    <div class="light-beam"></div>
    <div class="light-beam"></div>
    <div class="light-beam"></div>
    
    <!-- 主加载器 -->
    <div class="loader-wrapper">
      <!-- Logo 和标题 -->
      <div style="display: flex; flex-direction: column; align-items: center; gap: 20px;">
        <!-- 双Logo -->
        <div class="logo-container">
          <!-- Serverpod Logo -->
          <img src="https://serverpod.dev/assets/img/illustration.webp" 
               alt="Serverpod Logo" 
               class="logo-image"
               onerror="this.style.display='none'">

          <!-- Flutter Logo -->
          <img src="assets/icons/Flutter_335_Still_v01.png" 
               alt="Flutter Logo" 
               class="logo-image flutter-logo"
               onerror="this.style.display='none'">
        </div>
        
        <!-- 标题 -->
        <h1 class="app-title">Serverpod + Flutter Web Admin</h1>
      </div>
      
      <!-- 3D旋转环 -->
      <div class="rings-container">
        <div class="ring ring-1"></div>
        <div class="ring ring-2"></div>
        <div class="ring ring-3"></div>
        <div class="core"></div>
      </div>
      
      <!-- 进度条 -->
      <div style="display: flex; flex-direction: column; align-items: center;">
        <div class="progress-container">
          <div class="progress-bar" id="progress-bar"></div>
        </div>
        <div class="progress-info">
          <span class="progress-percent" id="progress-percent">0%</span>
          <span class="loading-stats" id="loading-stats">初始化中...</span>
        </div>
      </div>
      
      <!-- 加载文本 -->
      <div style="text-align: center;">
        <div class="loading-text">正在加载中...</div>
        <div class="loading-subtext">精彩即将呈现</div>
      </div>
    </div>
  </div>

  <!-- 粒子动画脚本 -->
  <script>
    (function() {
      const canvas = document.getElementById('particles-canvas');
      const ctx = canvas.getContext('2d');
      
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      
      const particles = [];
      const particleCount = 80;
      
      class Particle {
        constructor() {
          this.x = Math.random() * canvas.width;
          this.y = Math.random() * canvas.height;
          this.size = Math.random() * 2 + 0.5;
          this.speedX = Math.random() * 0.5 - 0.25;
          this.speedY = Math.random() * 0.5 - 0.25;
          this.opacity = Math.random() * 0.5 + 0.2;
          this.color = ['#6366f1', '#8b5cf6', '#ec4899'][Math.floor(Math.random() * 3)];
        }
        
        update() {
          this.x += this.speedX;
          this.y += this.speedY;
          
          if (this.x > canvas.width) this.x = 0;
          if (this.x < 0) this.x = canvas.width;
          if (this.y > canvas.height) this.y = 0;
          if (this.y < 0) this.y = canvas.height;
        }
        
        draw() {
          ctx.fillStyle = this.color;
          ctx.globalAlpha = this.opacity;
          ctx.beginPath();
          ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
          ctx.fill();
        }
      }
      
      function init() {
        for (let i = 0; i < particleCount; i++) {
          particles.push(new Particle());
        }
      }
      
      function animate() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.globalAlpha = 1;
        
        particles.forEach(particle => {
          particle.update();
          particle.draw();
        });
        
        // 绘制连线
        ctx.globalAlpha = 0.15;
        for (let i = 0; i < particles.length; i++) {
          for (let j = i + 1; j < particles.length; j++) {
            const dx = particles[i].x - particles[j].x;
            const dy = particles[i].y - particles[j].y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance < 120) {
              ctx.strokeStyle = '#6366f1';
              ctx.lineWidth = 0.5;
              ctx.beginPath();
              ctx.moveTo(particles[i].x, particles[i].y);
              ctx.lineTo(particles[j].x, particles[j].y);
              ctx.stroke();
            }
          }
        }
        
        requestAnimationFrame(animate);
      }
      
      init();
      animate();
      
      window.addEventListener('resize', () => {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
      });
    })();
  </script>

  <!-- 加载进度监控脚本 -->
  <script>
    (function() {
      const progressBar = document.getElementById('progress-bar');
      const progressPercent = document.getElementById('progress-percent');
      const loadingStats = document.getElementById('loading-stats');
      
      let currentProgress = 0;
      let targetProgress = 0;
      let totalResources = 0;
      let loadedResources = 0;
      let totalSize = 0;
      let loadedSize = 0;
      const startTime = Date.now();
      
      // 进度更新队列管理
      let lastStatusChangeTime = Date.now();
      let pendingUpdate = null;
      let isUpdating = false;
      const MIN_STATUS_DURATION = 300; // 每个状态最少显示600ms，确保可读
      
      // 更新进度条的函数（带最小显示时长控制）
      function updateProgress(progress, status) {
        const now = Date.now();
        const timeSinceLastChange = now - lastStatusChangeTime;
        
        // 如果有状态文字变化
        if (status && status !== loadingStats.textContent) {
          // 如果距离上次状态变化时间太短，延迟更新
          if (timeSinceLastChange < MIN_STATUS_DURATION && !isUpdating) {
            // 保存待更新的内容
            const delay = MIN_STATUS_DURATION - timeSinceLastChange;
            
            // 如果有待处理的更新，先取消
            if (pendingUpdate) {
              // 取消之前的待更新
            }
            
            pendingUpdate = { progress, status };
            
            // 设置延迟更新
            setTimeout(() => {
              if (pendingUpdate) {
                executeUpdate(pendingUpdate.progress, pendingUpdate.status);
                pendingUpdate = null;
              }
            }, delay);
            return;
          }
        }
        
        // 立即执行更新
        executeUpdate(progress, status);
      }
      
      // 执行实际的更新
      function executeUpdate(progress, status) {
        isUpdating = true;
        targetProgress = Math.min(progress, 95); // 最多到95%，等待Flutter真正加载完成
        
        // 平滑过渡到目标进度
        const smoothUpdate = () => {
          if (currentProgress < targetProgress) {
            currentProgress += (targetProgress - currentProgress) * 0.15;
            if (Math.abs(targetProgress - currentProgress) < 0.5) {
              currentProgress = targetProgress;
            }
            progressBar.style.width = currentProgress + '%';
            progressPercent.textContent = Math.floor(currentProgress) + '%';
            if (currentProgress < targetProgress) {
              requestAnimationFrame(smoothUpdate);
            }
          }
        };
        smoothUpdate();
        
        if (status && status !== loadingStats.textContent) {
          // 直接更新文字，无动画
          loadingStats.textContent = status;
          lastStatusChangeTime = Date.now();
        }
        
        isUpdating = false;
      }
      
      // 格式化文件大小
      function formatBytes(bytes) {
        if (bytes === 0) return '0 B';
        const k = 1024;
        const sizes = ['B', 'KB', 'MB', 'GB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return Math.round(bytes / Math.pow(k, i) * 100) / 100 + ' ' + sizes[i];
      }
      
      // ============================================
      // 真实进度监控: 资源加载 (异步并行执行)
      // 使用 PerformanceObserver 实时监听网络请求
      // 限制在30%-60%区间，避免跳跃太快
      // ============================================
      if (window.performance && window.PerformanceObserver) {
        const observer = new PerformanceObserver((list) => {
          for (const entry of list.getEntries()) {
            if (entry.initiatorType === 'script' || entry.initiatorType === 'fetch') {
              totalResources++;
              
              // 估算已加载的资源
              if (entry.responseEnd > 0) {
                loadedResources++;
                
                // 如果有transferSize信息，累加大小
                if (entry.transferSize) {
                  loadedSize += entry.transferSize;
                  totalSize += entry.transferSize;
                }
                
                // 计算进度 - 资源加载只占30%-60%的区间（缩小范围，避免跳太快）
                const resourceRatio = loadedResources / Math.max(totalResources, 1);
                const resourceProgress = 30 + (resourceRatio * 30); // 从30%到60%
                const elapsed = ((Date.now() - startTime) / 1000).toFixed(1);
                
                let status = `加载资源中 (${loadedResources}/${totalResources})`;
                if (loadedSize > 0) {
                  status = `已加载 ${formatBytes(loadedSize)} • ${elapsed}s`;
                }
                
                // 只有当新进度大于当前进度时才更新，且不超过60%
                if (resourceProgress > currentProgress && resourceProgress <= 60) {
                  updateProgress(resourceProgress, status);
                }
              }
            }
          }
        });
        
        observer.observe({ entryTypes: ['resource'] });
      }
      
      // ============================================
      // 并行机制1: 保底定时器（防止进度卡住）
      // 只有当实际进度低于目标时才会更新
      // ============================================
      let hasStartedLoading = false;
      
      // 阶段1: 初始化（0-10%）
      setTimeout(() => {
        if (currentProgress < 10) {
          updateProgress(10, '正在初始化...');
        }
      }, 200);
      
      // 阶段2: 加载引擎（10-20%）
      setTimeout(() => {
        if (currentProgress < 20) {
          updateProgress(20, '加载引擎中...');
        }
      }, 500);
      
      // 阶段3: 加载核心模块（20-30%）
      setTimeout(() => {
        if (currentProgress < 30) {
          updateProgress(30, '加载核心模块...');
        }
      }, 900);
      
      // 资源加载会在30%-60%区间实时更新（PerformanceObserver）
      
      // 阶段4: 准备渲染（60-65%）
      setTimeout(() => {
        if (currentProgress < 65) {
          updateProgress(65, '准备渲染...');
        }
      }, 2000);
      
      // 阶段5: 初始化框架（65-75%）
      setTimeout(() => {
        if (currentProgress < 75) {
          updateProgress(75, '初始化框架...');
        }
      }, 2500);
      
      // 阶段6: 渲染界面（75-85%）
      setTimeout(() => {
        if (currentProgress < 85) {
          updateProgress(85, '渲染界面...');
        }
      }, 3000);
      
      // 阶段7: 即将完成（85-90%）
      setTimeout(() => {
        if (currentProgress < 90) {
          updateProgress(90, '即将完成...');
        }
      }, 3500);
      
      // ============================================
      // 并行机制3: 字体加载监控（独立轮询）
      // 每100ms检查一次，与其他加载过程并行
      // ============================================
      let fontsLoaded = false;
      let flutterReady = false;
      
      function checkAndHideLoader() {
        // 只有当 Flutter 就绪且字体加载完成时才隐藏加载器
        // 这是一个"与"关系，两个条件必须都满足
        if (flutterReady && fontsLoaded) {
          updateProgress(100, '加载完成！');
          progressPercent.textContent = '100%';
          
          
          setTimeout(() => {
            const loadingContainer = document.getElementById('loading-container');
            loadingContainer.classList.add('fade-out');
            setTimeout(() => {
              loadingContainer.style.display = 'none';
            }, 800);
          }, 300);
        }
      }
      
      // 字体加载监控（并行执行）
      if (document.fonts && document.fonts.ready) {
        let fontLoadStartTime = 0;
        let fontLoadingStarted = false;
        
        // 使用更简单的方式：监听 document.fonts 的 size 变化
        const initialFontCount = document.fonts.size;
        let lastFontCount = initialFontCount;
        
        // 定期检查字体加载状态
        const fontCheckInterval = setInterval(() => {
          const currentFontCount = document.fonts.size;
          
          // 检测到字体开始加载
          if (currentFontCount > lastFontCount && !fontLoadingStarted) {
            fontLoadingStarted = true;
            fontLoadStartTime = Date.now();
          }
          
          if (fontLoadingStarted) {
            const elapsed = ((Date.now() - fontLoadStartTime) / 1000).toFixed(1);
            const loadedCount = currentFontCount - initialFontCount;
            
            // 模拟渐进式加载（基于时间）
            if (currentProgress >= 90 && currentProgress < 95) {
              if (elapsed < 0.5) {
                updateProgress(91, `加载字体中...`);
              } else if (elapsed < 1.0) {
                updateProgress(93, `加载字体中...`);
              } else {
                updateProgress(94, `加载字体中...`);
              }
            }
          }
          
          lastFontCount = currentFontCount;
        }, 100);
        
        // 等待所有字体加载完成
        document.fonts.ready.then(() => {
          clearInterval(fontCheckInterval);
          fontsLoaded = true;
          updateProgress(95, '加载完成！');
          checkAndHideLoader();
        });
        
        // 超时保护：最多等待5秒字体加载
        setTimeout(() => {
          clearInterval(fontCheckInterval);
          if (!fontsLoaded) {
            fontsLoaded = true;
            checkAndHideLoader();
          }
        }, 5000);
      } else {
        // 浏览器不支持 Font Loading API，直接标记为完成
        fontsLoaded = true;
      }
      
      // ============================================
      // 并行机制4: Flutter 就绪事件（异步回调）
      // 由 Flutter 引擎在首帧渲染完成后触发
      // 与其他所有机制完全并行执行
      // ============================================
      window.addEventListener('flutter-first-frame', function() {
        flutterReady = true;
        // Flutter 渲染完成后，让字体加载接管进度显示
        // 不在这里更新进度，由字体加载监控来显示
        checkAndHideLoader(); // 尝试隐藏（需要同时满足 fontsLoaded）
      });
      
      // 超时保护：如果30秒还没加载完成，强制显示高进度
      setTimeout(() => {
        if (currentProgress < 90) {
          updateProgress(90, '正在完成最后步骤...');
        }
      }, 30000);
      
    })();
  </script>

  <script src="flutter_bootstrap.js" async></script>
</body>
</html>
